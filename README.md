# -
C语言实现多表代换密码算法


多表代换密码算法描述：
首先将明文M分为由N个字母构成的分组M1，M2，…，Mj，对每个分组Mi的加密为：
                                    Ci = AMi+B(mod N), i=1,2,…,j


其中(A,B)是密钥，A是n*m的可逆矩阵，
满足gcd(|A|,N)=1(|A|是行列式)。B=(B1,B2,…,Bn)T, C=(C1,C2,…,Cn)T, Mi=(m1,m2,…,mn)T。
对密文分组Ci的解密为：
                                   Mi=A-1(Ci-B)(mod N),i=1,2,…,j

实现难点：

矩阵运算的实现：

            密码算法将文本即字母转化为0到26的数字，所以算法中所用到的矩阵运算是在模26的整数上。


求矩阵行列式：

          采用递归实现，每次递归按第一行展开，当矩阵为一维时行列式即是矩阵内容，返回。


求伴随矩阵：

          注意代数余子式的角标与矩阵中的实际位置不同，需要“转置”。


求逆矩阵：
  
          采用 A^(-1) = A* / det A实现，实际实现上除以行列式等于乘以行列式的乘法逆元。
          
          
分组填充：
  
          加解密时要对明文或密文进行分组，这个分组的长度是根据密钥A的阶数决定。
          在对明文分组时会出现不能完全分组的情况，需要考虑填充进行完全分组。
          我采用的方法是在最后一组中填充字母O。
          
          
          解密时如何去除填充，这个问题不知道怎么解决。
          
          
我实现使用的是C语言，写得比较死，实际用处不大，只是实现了简单的读入输入字符，生成随机密钥，加密，解密验证。

文件中有一个矩阵运算实现的头文件，加解密实现的c源文件。
